# VK-based SOCKS5 Tunnel

## Обзор

Этот проект реализует SOCKS5 туннель поверх API сообщений ВКонтакте. Он предназначен для обхода сетевых ограничений ("белых списков"), в которых разрешен доступ к `vk.com`, но заблокированы другие ресурсы.

Архитектура использует два сообщества ВКонтакте (бота), которые общаются в общем чате, что обеспечивает стабильность и обход ограничений API.

## Компоненты

- `client.py`: Локальный SOCKS5-прокси (клиент).
- `server.py`: Удаленный сервер туннеля.
- `app_logic.py`: Общая логика для клиента и сервера (воркеры отправки, обработка DATA сообщений, graceful shutdown).
- `protocol.py`: Определяет протокол обмена сообщениями, включая логику отправки данных и сбор статистики.
- `vk_api.py`: Функции для взаимодействия с VK API (отправка сообщений, Long Poll).
- `chat_rotator.py`: Управление списком чатов для распределения нагрузки.
- `config.py`: Загрузка конфигурации (токены VK API, ID групп и чатов) из переменных окружения.
- `constants.py`: Определение различных констант для протокола, производительности и сервера SOCKS5.
- `requirements.txt`: Зависимости проекта.
- `fck-whitelist.service`: Пример systemd сервиса для запуска сервера в фоне.

## Настройка

Вам понадобится создать **два сообщества ВКонтакте** и получить для них токены.

**1. Настройка Сообществ (проделать для обоих):**
- Создайте два новых сообщества (паблика) в VK. Одно будет "клиентом", другое "сервером".
- В настройках каждого сообщества перейдите в `Управление` -> `Работа с API`.
- На вкладке **Long Poll API**: убедитесь, что API `Включен`.
- На вкладке **Типы событий**: поставьте галочку `Входящее сообщение`.
- На вкладке **Ключи доступа**: создайте новый ключ доступа.
- Дайте ключу права: `сообщения` и `управление`.
- В настройках сообщества перейдите в `Управление` -> `Сообщения`.
- Убедитесь, что "Сообщения сообщества" `Включены`.
- Нажмите "Настройки для бота" и включите опции `Разрешать добавлять сообщество в беседы` и установите `Возможности ботов` в положение `Включены`.

**2. Создание общего чата:**
- С вашего личного аккаунта создайте новую беседу (чат).
- Добавьте в нее оба ваших сообщества (через упоминание `@имя_сообщества`).
- Узнайте `peer_id` этого чата. Самый простой способ: откройте чат в браузере, и в адресной строке будет `.../im/convo/XXXXXXXXX`. Ваш `peer_id` — это `XXXXXXXXX`.

**3. Настройка переменных окружения:**
Создайте файл `.env` в корне проекта на основе `.env.example` и заполните его:
  - `VK_SERVER_TOKEN`: Токен сообщества-сервера.
  - `VK_SERVER_GROUP_ID`: ID сообщества-сервера (только цифры).
  - `VK_CLIENT_TOKEN`: Токен сообщества-клиента.
  - `VK_CLIENT_GROUP_ID`: ID сообщества-клиента.
  - `VK_CHAT_PEER_ID`: `peer_id` вашего общего чата. Если используете несколько чатов, укажите их через запятую (например, `123,456,789`).

**4. Установка зависимостей:**
```bash
pip install -r requirements.txt
```

## Использование

1.  **Запустите сервер** на вашей удаленной машине:
    ```bash
    python3 server.py
    ```
    Рекомендуется настроить его как `systemd` сервис для работы в фоне (см. `fck-whitelist.service`).

2.  **Запустите клиент** на вашей локальной машине:
    ```bash
    python3 client.py
    ```

3.  **Настройте ваш браузер/ОС:**
    - Установите прокси-сервер на **SOCKS5**.
    - **Хост:** `127.0.0.1`
    - **Порт:** `8888`

---

## Детали Архитектуры

Проект представляет собой TCP-туннель, использующий API сообщений ВКонтакте в качестве транспортного уровня. Он предназначен для обхода сетевых ограничений (вайтлистов), в которых разрешен доступ к `vk.com`, но заблокированы другие ресурсы.

Туннель работает по протоколу SOCKS5, что позволяет проксировать любой TCP-трафик, включая HTTPS, SSH и т.д.

### Ключевые принципы

1.  **Модель "Сообщество-Сообщество":** Для обхода ограничений VK API (CAPTCHA, лимиты) используется архитектура, где оба участника обмена являются сообществами, общающимися в общем групповом чате.
2.  **Надежная передача данных:**
    *   **Очередь пакетов:** На сервере реализована очередь (`asyncio.PriorityQueue`) для обработки входящих `DATA`-сообщений от клиента. Пакеты извлекаются из очереди в строгом порядке `MessageID`, обеспечивая целостность потока данных. Клиент также использует буфер для обработки пакетов, приходящих не по порядку.
    *   **Адаптивный транспорт:** Для передачи данных используется два механизма:
        *   Малые чанки данных (до `TEXT_MESSAGE_THRESHOLD`, определенного в `constants.py`) отправляются как Base64-кодированные текстовые сообщения, разделенные на несколько частей.
        *   Большие чанки данных (свыше `TEXT_MESSAGE_THRESHOLD`) отправляются как вложения-документы через VK API.
    *   **Механизм повторных попыток:** Функции отправки сообщений (`api_call` в `vk_api.py`) имеют встроенный механизм повторных попыток при ошибках VK API (например, `Flood Control`).
3.  **Статистика и мониторинг:** Протокол включает `SessionMetrics` для сбора детальной статистики по каждой сессии (отправлено/получено байт, пакеты, латентность, ошибки), что помогает в мониторинге и отладке.

### Протокол сообщения

Сообщения имеют заголовочную структуру, отделенную от тела пустой строкой.

```
To: [client/server]
Type: [connect/data/ack/close]
SessionID: [ID сессии]
MessageID: [Порядковый номер]
Part: [Индекс части/Всего частей] (только для многочастных DATA сообщений)

[ДАННЫЕ в Base64, если они есть]
```

### Описание Компонентов

#### `app_logic.py`
- **Роль:** Содержит переиспользуемую логику, общую для клиента и сервера.
- **Функционал:**
    - `sender_worker`: Воркеры для параллельной отправки сообщений в VK API.
    - `process_data_message`: Обработка входящих `DATA`-сообщений, включая сборку multi-part сообщений и скачивание вложений.
    - `handle_shutdown`: Универсальная логика для graceful shutdown обоих компонентов.

#### `client.py` (Клиент)
- **Роль:** Запускает локальный SOCKS5-прокси и инициирует туннельные сессии.
- **Функционал:**
    1. Запускает SOCKS5-сервер на `localhost:8888`.
    2. Принимает TCP-соединения от браузера/ОС.
    3. Инициирует туннельную сессию, отправляя `CONNECT`-сообщение на сервер.
    4. `uplink_handler`: Читает данные из браузера, буферизует, делит на чанки и передает в очередь отправки.
    5. `client_writer_task`: Обрабатывает входящие `DATA`-сообщения от сервера, восстанавливает порядок пакетов (используя буфер) и записывает данные обратно в сокет браузера.
    6. Использует `ChatRotator` для выбора `peer_id` при отправке сообщений.

#### `server.py` (Сервер)
- **Роль:** Удаленный сервер туннеля, обрабатывает запросы от клиента и перенаправляет трафик.
- **Функционал:**
    1. `long_poll_listener`: Слушает входящие сообщения от клиента через VK Long Poll API.
    2. `handle_client_message`: Обрабатывает `CONNECT` и `CLOSE` сообщения. При `CONNECT` устанавливает соединение с целевым хостом. При `DATA` помещает данные в приоритетную очередь сессии.
    3. `server_writer_task`: Для каждой активной сессии устанавливает соединение с конечным ресурсом, забирает пакеты из очереди в строгом порядке `MessageID` и записывает их в сокет целевого хоста.
    4. `downlink_handler`: Читает ответ от целевого хоста, буферизует, делит на чанки и передает в очередь отправки клиенту.
    5. Использует `ChatRotator` для выбора `peer_id` при отправке сообщений.

#### `vk_api.py`
- **Роль:** Абстракция для взаимодействия с API ВКонтакте.
- **Функционал:**
    - `api_call()`: Обобщенная функция для вызова методов VK API с обработкой ошибок и повторных попыток.
    - `start_long_poll_listener()`: Запускает Long Poll клиент для прослушивания входящих сообщений.
    - Функции для работы с документами (загрузка, получение URL).

#### `chat_rotator.py`
- **Роль:** Обеспечивает циклическое переключение между заданными `peer_id` чатами.
- **Функционал:**
    - `get_next_peer_id()`: Возвращает следующий `peer_id` из списка по кругу, обеспечивая равномерное использование чатов.

#### `config.py`
- **Роль:** Управляет загрузкой конфигурационных параметров.
- **Функционал:**
    - Использует `python-dotenv` для загрузки переменных окружения из `.env` файла.
    - Предоставляет токены VK API, ID групп и ID чатов.

#### `constants.py`
- **Роль:** Определяет общие константы.
- **Функционал:**
    - Перечисления для типов сообщений (`MessageType`), целей (`Target`), команд SOCKS (`SocksCmd`) и типов адресов (`SocksAtyp`).
    - Параметры производительности: `MAX_CHUNK_SIZE`, `CHUNK_TIMEOUT`, `NUM_SENDER_WORKERS`, `MAX_TEXT_MESSAGE_PAYLOAD`, `TEXT_MESSAGE_THRESHOLD`, `UPLOAD_URL_CACHE_TTL`.
    - Параметры буферизации и очередей: `MAX_PACKET_BUFFER_SIZE`, `PACKET_BUFFER_TIMEOUT`, `SENDER_QUEUE_MAX_SIZE`.
    - Конфигурация локального SOCKS5-сервера: `SOCKS_SERVER_HOST`, `SOCKS_SERVER_PORT`.
    - Флаг `ENABLE_SESSION_STATISTICS` для включения/выключения сбора статистики.

### Тюнинг производительности

Ключевыми параметрами для настройки баланса "скорость/стабильность" являются:
- `CHUNK_TIMEOUT`: Таймаут в секундах для отправки частично заполненного буфера. Меньшее значение увеличивает интерактивность, но может увеличить количество сообщений.
- `NUM_SENDER_WORKERS`: Количество параллельных воркеров для отправки сообщений. Увеличение может повысить пропускную способность, но также потребление ресурсов.
- `TEXT_MESSAGE_THRESHOLD`: Порог (в байтах) для переключения между отправкой данных как текстовых сообщений (быстрее для малых объемов) и как документов (эффективнее для больших объемов).

Рекомендуется экспериментировать с этими параметрами в `constants.py` для достижения оптимальной производительности в вашей среде.