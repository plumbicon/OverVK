# VK-based SOCKS5 Tunnel

## Обзор

Этот проект позволяет туннелировать любой TCP-трафик через сообщения ВКонтакте. Он предназначен для обхода сетевых ограничений ("белых списков"), в которых разрешен доступ к `vk.com`, но заблокированы другие ресурсы.

Архитектура использует двух ботов (два сообщества ВКонтакте), которые общаются в общем чате, что обеспечивает стабильность и обход ограничений API, таких как CAPTCHA.

## Компоненты

- `client.py`: Локальный SOCKS5-прокси (клиент).
- `server.py`: Удаленный сервер туннеля.
- `config.py`: Файл для ваших учетных данных VK API.
- `requirements.txt`: Зависимости проекта.

## Настройка

Вам понадобится создать **два сообщества ВКонтакте** и получить для них токены.

**1. Настройка Сообществ (проделать для обоих):**
- Создайте два новых сообщества (паблика) в VK. Одно будет "клиентом", другое "сервером".
- В настройках каждого сообщества перейдите в `Управление` -> `Работа с API`.
- На вкладке **Long Poll API**: убедитесь, что API `Включен`.
- На вкладке **Типы событий**: поставьте галочку `Входящее сообщение`.
- На вкладке **Ключи доступа**: создайте новый ключ доступа.
- Дайте ключу права: `сообщения` и `управление`.
- В настройках сообщества перейдите в `Управление` -> `Сообщения`.
- Убедитесь, что "Сообщения сообщества" `Включены`.
- Нажмите "Настройки для бота" и включите опции `Разрешать добавлять сообщество в беседы` и установите `Возможности ботов` в положение `Включены`.

**2. Создание общего чата:**
- С вашего личного аккаунта создайте новую беседу (чат).
- Добавьте в нее оба ваших сообщества (через упоминание `@имя_сообщества`).
- Узнайте `peer_id` этого чата. Самый простой способ: откройте чат в браузере, и в адресной строке будет `.../im/convo/XXXXXXXXX`. Ваш `peer_id` — это `XXXXXXXXX`.

**3. Настройка `config.py`:**
- Откройте `config.py` и заполните все 5 полей:
  - `VK_SERVER_TOKEN`: Токен сообщества-сервера.
  - `VK_SERVER_GROUP_ID`: ID сообщества-сервера (только цифры).
  - `VK_CLIENT_TOKEN`: Токен сообщества-клиента.
  - `VK_CLIENT_GROUP_ID`: ID сообщества-клиента.
  - `VK_CHAT_PEER_ID`: `peer_id` вашего общего чата.

**4. Установка зависимостей:**
```bash
pip install -r requirements.txt
```

## Использование

1.  **Запустите сервер** на вашей удаленной машине:
    ```bash
    python3 server.py
    ```
    Рекомендуется настроить его как `systemd` сервис для работы в фоне (см. `fck-whitelist.service`).

2.  **Запустите клиент** на вашей локальной машине:
    ```bash
    python3 client.py
    ```

3.  **Настройте ваш браузер/ОС:**
    - Установите прокси-сервер на **SOCKS5**.
    - **Хост:** `127.0.0.1`
    - **Порт:** `8888`

---

## Детали Архитектуры

Проект представляет собой TCP-туннель, использующий API сообщений ВКонтакте в качестве транспортного уровня. Он предназначен для обхода сетевых ограничений (вайтлистов), в которых разрешен доступ к `vk.com`, но заблокированы другие ресурсы.

Туннель работает по протоколу SOCKS5, что позволяет проксировать любой TCP-трафик, включая HTTPS, SSH и т.д.

### Ключевые принципы

1.  **Модель "Сообщество-Сообщество":** Для обхода ограничений VK API (CAPTCHA, лимиты) используется архитектура, где оба участника обмена являются сообществами, общающимися в общем групповом чате.

2.  **Очередь пакетов на сервере:** Для борьбы с нарушением порядка пакетов при быстрой передаче данных (что приводило к ошибкам TLS), на сервере реализована очередь (`asyncio.PriorityQueue`). Все входящие `data`-сообщения от клиента сначала помещаются в эту очередь. Отдельная задача-обработчик (`server_writer_task`) затем берет пакеты из очереди в строгом порядке их `MessageID` и пишет в конечный сокет. Это гарантирует целостность потока данных.

3.  **Адаптивный транспорт:** Протокол обмена сообщениями построен на базе текстовых заголовков, что делает его гибким. Для повышения пропускной способности все данные сжимаются с помощью `zlib` и кодируются в `Base64`.

4.  **Механизм повторных попыток (Retry):** Функция отправки сообщений (`send_vk_message`) имеет встроенный цикл повторных попыток. При ошибке со стороны VK API (например, `Flood Control`), функция не падает, а ждет несколько секунд и пытается отправить сообщение снова.

### Протокол сообщения

Сообщения имеют заголовочную структуру, отделенную от тела пустой строкой.

```
To: [client/server]
Type: [connect/data/ack/close]
SessionID: [ID сессии]
MessageID: [Порядковый номер]

[ДАННЫЕ в Base64, если они есть]
```

### Описание Компонентов

#### `common.py`
- **Роль:** Содержит переиспользуемый код для обоих компонентов.
- **Функционал:**
    - `VkontakteApiError`: Кастомное исключение для ошибок API.
    - `api_call()`: Обобщенная функция для вызова методов VK API. Принимает токен доступа как аргумент.
    - `send_vk_message()`: Собирает и отправляет сообщение в заголовочном формате, включает в себя логику повторных попыток.

#### `client.py` (Клиент)
- **Роль:** Действует от имени "клиентского" сообщества.
- **Функционал:**
    1. Запускает локальный SOCKS5-сервер на `localhost:8888`.
    2. Принимает TCP-соединения и инициирует туннельную сессию, отправляя `connect`-сообщение с заголовком `To: server`.
    3. `uplink_handler`: читает данные от браузера, нарезает на чанки, сжимает, кодирует в Base64 и последовательно отправляет `data`-сообщения с инкрементируемым `MessageID`.
    4. `long_poll_listener`: слушает сообщения от сервера (с `To: client`), декодирует, разжимает и пишет данные в сокет браузера.

#### `server.py` (Сервер)
- **Роль:** Действует от имени "серверного" сообщества.
- **Функционал:**
    1. `long_poll_listener`: слушает сообщения от клиента (с `To: server`).
    2. `handle_incoming_message`: При получении `connect` создает сессию и отправляет `ack`. При получении `data`, помещает пару `(MessageID, payload)` в приоритетную очередь сессии.
    3. `server_writer_task`: Для каждой сессии запускается эта задача. Она устанавливает соединение с конечным сайтом (например, `google.com`) и в цикле забирает пакеты из очереди в строгом порядке, декодирует, разжимает и пишет их в сокет.
    4. `downlink_handler`: Читает ответ от конечного сайта и отправляет его `data`-сообщениями клиенту.

### Тюнинг производительности

Ключевым параметром для настройки баланса "скорость/стабильность" является `MIN_SEND_DELAY_SECONDS` в `client.py` и `server.py`. Уменьшение этого значения увеличит скорость, но может привести к ошибкам `Flood Control`.